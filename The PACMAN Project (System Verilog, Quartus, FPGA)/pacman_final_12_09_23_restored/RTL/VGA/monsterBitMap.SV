// bitmap file 
// (c) Technion IIT, Department of Electrical and Computer Engineering 2023 
// generated by the automatic Python tool 
 
 
 module monsterBitMap (

					input	logic	clk, 
					input	logic	resetN, 
					input logic	[10:0] offsetX,// offset from top left  position 
					input logic	[10:0] offsetY, 
					input	logic	InsideRectangle, //input that the pixel is within a bracket
					input logic gamePlaying, // up if game is playable
					input logic switchState, // pulse to switch between monster states (red and green)
					input logic startOfFrame,
					input logic pacman_collision, // collision of monster with pacman
 
					output logic drawingRequest, //output that the pixel should be dispalyed 
					output logic [7:0] RGBout,  //rgb value from the bitmap 
					output logic [4:0] addHP, // amount of HP to add
					output logic [4:0] removeHP, // amount of HP to remove
					output logic monsterAlive, // up if monster is alive
					output logic [3:0] HitEdgeCode //one bit per edge 
 ) ; 
 
 
// generating the bitmap

localparam logic [7:0] TRANSPARENT_ENCODING = 8'h00; // RGB value in the bitmap representing a transparent pixel 
localparam logic [7:0] RED_ENCODING = 8'he4;
localparam logic [7:0] GREEN_ENCODING = 8'h10;
localparam logic [0:3][7:0] colors = {8'h00, 8'he4, 8'h6d, 8'hff}; // colors used in bitmap
logic[0:31][0:31][1:0] object_colors = {
	{2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0},
	{2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0},
	{2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0},
	{2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0},
	{2'h0,2'h0,2'h0,2'h0,2'h0,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h0,2'h0,2'h0,2'h0,2'h0},
	{2'h0,2'h0,2'h0,2'h0,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h0,2'h0,2'h0,2'h0},
	{2'h0,2'h0,2'h0,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h0,2'h0,2'h0},
	{2'h0,2'h0,2'h0,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h0,2'h0,2'h0},
	{2'h0,2'h0,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h0,2'h0},
	{2'h0,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h0},
	{2'h0,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h3,2'h3,2'h3,2'h3,2'h3,2'h1,2'h1,2'h1,2'h1,2'h1,2'h3,2'h3,2'h3,2'h3,2'h3,2'h1,2'h1,2'h1,2'h0},
	{2'h0,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h3,2'h3,2'h3,2'h3,2'h3,2'h3,2'h3,2'h1,2'h1,2'h1,2'h3,2'h3,2'h3,2'h3,2'h3,2'h3,2'h3,2'h1,2'h1,2'h0},
	{2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h3,2'h3,2'h3,2'h3,2'h2,2'h2,2'h2,2'h3,2'h3,2'h1,2'h3,2'h3,2'h3,2'h3,2'h2,2'h2,2'h2,2'h3,2'h3,2'h1,2'h1},
	{2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h3,2'h3,2'h3,2'h3,2'h2,2'h2,2'h2,2'h3,2'h3,2'h1,2'h3,2'h3,2'h3,2'h3,2'h2,2'h2,2'h2,2'h3,2'h3,2'h1,2'h1},
	{2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h3,2'h3,2'h3,2'h3,2'h2,2'h2,2'h2,2'h3,2'h3,2'h1,2'h3,2'h3,2'h3,2'h3,2'h2,2'h2,2'h2,2'h3,2'h3,2'h1,2'h1},
	{2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h3,2'h3,2'h3,2'h3,2'h3,2'h3,2'h3,2'h1,2'h1,2'h1,2'h3,2'h3,2'h3,2'h3,2'h3,2'h3,2'h3,2'h1,2'h1,2'h1},
	{2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h3,2'h3,2'h3,2'h3,2'h3,2'h1,2'h1,2'h1,2'h1,2'h1,2'h3,2'h3,2'h3,2'h3,2'h3,2'h1,2'h1,2'h1,2'h1},
	{2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1},
	{2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1},
	{2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1},
	{2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1},
	{2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1},
	{2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1},
	{2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1},
	{2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1},
	{2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1},
	{2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1},
	{2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1},
	{2'h1,2'h1,2'h1,2'h1,2'h1,2'h0,2'h0,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h0,2'h0,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h0,2'h0,2'h1,2'h1,2'h1,2'h1,2'h1},
	{2'h1,2'h1,2'h1,2'h1,2'h0,2'h0,2'h0,2'h0,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h0,2'h0,2'h0,2'h0,2'h1,2'h1,2'h1,2'h1,2'h1,2'h1,2'h0,2'h0,2'h0,2'h0,2'h1,2'h1,2'h1,2'h1},
	{2'h1,2'h1,2'h1,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h1,2'h1,2'h1,2'h1,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h1,2'h1,2'h1,2'h1,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h1,2'h1,2'h1},
	{2'h1,2'h1,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h1,2'h1,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h1,2'h1,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h0,2'h1,2'h1}};

 // state machine decleration 
enum logic [2:0] {s_idle, s_red, s_green} monster_ps, monster_ns;
 
logic [3:0] respawnCounter = 4'h0;
int	secCounter = 0; // one second counter
logic respawnFlag = 1'b0; // up if respawn is needed
logic pacman_collision_D; // delay of pacman_collision

//////////--------------------------------------------------------------------------------------------------------------= 
//hit bit map has one bit per edge:  hit_colors[3:0] =   {Left, Top, Right, Bottom}	 
//there is one bit per edge, in the corner two bits are set  
 logic [0:3] [0:3] [3:0] hit_colors = 
		   {16'hC446,     
			16'h8C62,    
			16'h8932, 
			16'h9113}; 
 // pipeline (ff) to get the pixel color from the array 	 
//////////--------------------------------------------------------------------------------------------------------------= 
always_ff@(posedge clk or negedge resetN) 
begin 
	if(!resetN) begin
		monster_ps <= s_idle;
		RGBout <= TRANSPARENT_ENCODING; 
		HitEdgeCode <= 4'h0;
		pacman_collision_D <= 1'b0;
		addHP <= 5'h0;
		removeHP <= 5'h0;
		respawnCounter <= 4'h0;
		monsterAlive <= 1'b1;
		secCounter <= 0;
	end 
	else begin
		// defaults
		monster_ps <= monster_ns;
		RGBout <= TRANSPARENT_ENCODING;
		HitEdgeCode <= 4'h0;
		addHP <= 5'h0;
		removeHP <= 5'h0;
		pacman_collision_D <= pacman_collision;
		
		if (gamePlaying == 1'b0) begin // reset when game isnt playable
			monster_ps <= s_idle;
			respawnCounter <= 4'h0;
			secCounter <= 0;
			respawnFlag <= 1'b0;
			monsterAlive <= 1'b1;
		end
		else begin
			if (InsideRectangle == 1'b1 && monsterAlive == 1'b1)
			begin // inside an external bracket
				HitEdgeCode <= hit_colors[offsetY >> 3][offsetX >> 3]; // get hitting edge from the colors table
				// act based on state of monster
				if (monster_ps == s_red) begin
					RGBout <= colors[object_colors[offsetY][offsetX]];
					if (pacman_collision && !pacman_collision_D)
						removeHP <= 5'd25;
				end
				else if (monster_ps == s_green) begin
					RGBout <= (colors[object_colors[offsetY][offsetX]] == RED_ENCODING) ? GREEN_ENCODING : colors[object_colors[offsetY][offsetX]];
					if (pacman_collision && !pacman_collision_D) begin
						addHP <= 5'd10;
						monster_ps <= s_idle;
						respawnFlag <= 1'b1;
						monsterAlive <= 1'b0;
					end
				end
			end
			if (respawnFlag == 1'b1) begin // deal with respawn
				secCounter <= secCounter + 1;
				if (respawnCounter == 4'hf) begin // about 15 seconds
					respawnCounter <= 4'h0;
					secCounter <= 0;
					respawnFlag <= 1'b0;
					monsterAlive <= 1'b1;
				end
				else if (secCounter == 31500000) begin // count to one second
					secCounter <= 0;
					respawnCounter <= respawnCounter + 1'b1;
				end
			end
		end
	end
end  

always_comb // Update next state and outputs
	begin
	// set all default values 
		monster_ns = monster_ps;
			
		case (monster_ps)
		
			s_idle: begin
					if (gamePlaying == 1'b1 && monsterAlive == 1'b1)
						monster_ns = s_red;
				end
						
			s_red: begin
					if (switchState == 1'b1)
						monster_ns = s_green;
				end
				
			s_green: begin
					if (switchState == 1'b1)
						monster_ns = s_red;
				end
		endcase
	end // always comb

//////////--------------------------------------------------------------------------------------------------------------= 
// decide if to draw the pixel or not 
assign drawingRequest = (RGBout != TRANSPARENT_ENCODING ) ? 1'b1 : 1'b0 ; // get optional transparent command from the bitmpap   
 
endmodule 
